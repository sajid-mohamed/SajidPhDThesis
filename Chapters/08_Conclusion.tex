\chapter{Conclusions and Future Work}
\label{chap:concl}

\glsresetall

Multiprocessor \gls{ibc} systems will only become more prominent and visible in the upcoming future.
The prime driving factors for adopting multiprocessor \gls{ibc} systems are the advances in the semiconductor industry, and the ease and necessity of connectivity, e.g., using 5G (and even 6G), for the modern industrial systems, devices and utilities.
The advances in the semiconductor industry are driving down the price and size (form factor) of multiprocessors and high quality \gls{cmos} cameras. 
A connected world improves the overall efficiency and productivity of modern systems and the connected humans.
Seamless connectivity enables data-intensive processing in the cloud and allows the integration of camera sensors as edge devices in modern industrial systems.
A camera can sense multiple physical parameters and can be (re-)configured with only a software update.
This thesis explores how we can effectively optimise  multiprocessor \gls{ibc} systems implementation and addresses some of the fundamental challenges with its adoption in industrial systems.

\section{Conclusions}
Multiprocessor \gls{ibc} systems are a class of data-intensive feedback control systems whose feedback is provided by image-based sensing using cameras as sensors and implemented on a multiprocessor platform. 
Multiprocessor \gls{ibc} systems have become popular with the advent of efficient image-processing algorithms, low-cost \gls{cmos} cameras with high resolution and low-cost multiprocessor platforms. 
The combination of the camera and the image-processing algorithm gives necessary information on parameters such as relative position, geometry, relative distance, depth perception and tracking of the object-of-interest. 
This enables the effective use of low-cost camera sensors to enable new functionality or replace expensive sensors in cost-sensitive industries like automotive and automation. 
Applications of multiprocessor \gls{ibc} systems are found in robotics, autonomous vehicles, \gls{adas}, electron microscopes, visual navigation and so on.

The challenge, however, is that the image-processing algorithms are compute-intensive and result in an inherent relatively long sensing delay. State-of-the-art design methods do not fully exploit the \gls{ibc} system characteristics and advantages of the multiprocessor platforms for optimising the sensing delay. 
The sensing delay of an \gls{ibc} system is moreover variable with a significant degree of variation between the best-case and worst-case delay due to application-specific image-processing workload variations and the impact of platform resources. A long variable sensing delay degrades system performance and stability. A tight predictable sensing delay is required to optimise the \gls{ibc} system performance and to guarantee the stability of the \gls{ibc} system. Analytical computation of sensing delay is often pessimistic due to image-dependent workload variations or challenging platform timing analysis. Therefore, this thesis explores techniques to cope with the long variable sensing delay by considering application-specific \gls{ibc} system characteristics and exploiting the benefits of the multiprocessor platforms. Effectively handling the long variable sensing delay helps to optimise \gls{ibc} system performance while guaranteeing \gls{ibc} system stability.

In the first contribution, the \gls{spade} flow is proposed that relates the formal dataflow timing analysis with control timing parameters for the formal controller design.
This thesis proposes the first formal model-based design framework for the \gls{ibc} system co-design that relates dataflow analysis and controller design. 
The \gls{spade} flow brings together dataflow and control formalisms in the same framework.
This relation allows to bring in the optimisation techniques from the dataflow domain into the control timing parameter optimisation. 
The first contribution also examines the case of application parallelism with no pipelining allowed for the control loop and thereby, reduces the sensor-to-actuator delay and period of the resulting controller implementation.
The proposed \gls{spade} flow also makes a step forward towards real-life implementation by detailing how the flow can be adapted for industrial platforms. Both academic and industrial platforms could implement the \gls{spade} approach.

The second contribution integrates the parameters relevant for a practical pipelined implementation. 
A pipelined implementation reduces the sampling period while keeping the sensor-to-actuator delay constant.
Inter-frame dependencies are present in many modern computer-vision algorithms. Such algorithms, when used in an IBC setting, require to model such algorithmic artefact at the control level. Moreover, system nonlinearities and constraints on system variables are other common factors encountered in almost all real-life settings. This thesis explicitly considers application-specific inter-frame dependencies and their impact on the controller implementation. This thesis presents a \gls{mpc} formulation for pipelined \gls{ibc} systems considering workload variations, inter-frame dependencies, system nonlinearities and constraints on system variables.
This thesis, thus, makes a step towards a real-life pipelining implementation for \gls{ibc} systems.

The third contribution, in essence, brings together the advantages of the above two contributions in the \gls{spade} flow for pipelined parallelism.  Pipelined parallelism effectively reduces both the sampling period and sensor-to-actuator delay while taking into account both the degree of application parallelism (determined by the algorithm and the given platform allocation) and the degree of pipelining (quantified by inter-frame dependencies and the given platform allocation).
An algorithm is detailed for the \gls{spade} flow with modular blocks for binding and scheduling, controller design and timing analysis. These blocks are modular as any state-of-the-art technique could be used instead of those used in this thesis: i) the SDF3 tool for binding and scheduling; ii) the \gls{lqr}, \gls{lqi}, \gls{lqg}, \gls{mpc}, and \gls{mjls} controller design techniques; and iii) max-plus algebra for timing analysis. 
This thesis presents the required model transformations for realizing \gls{spade} using the \gls{sadf} \gls{moc}.
This thesis also details the adaptation of the \gls{spade} flow for industrial platforms for pipelined parallelism.

The fourth contribution explicitly takes into account the application-specific workload variations and particularly considers the switching probabilities between the workload scenarios.
Considering these workload variations and switching probabilities implies that we can reduce the average sensor-to-actuator delay and the average sampling period of the controller implementation. 
In literature, variable sensor-to-actuator delay (resulting from the variable workload) was dealt with through switched linear controllers with either known or unknown sequences of delay occurrences. These solutions either suffer from poor performance (from unknown arbitrary delay sequences) or unrealistic assumptions (when knowledge of the delay sequence is not available in reality). 
This thesis proposes an alternative controller design method based on the \gls{mjls} formulation.
The image-workload variations are identified and modelled as a \gls{dtmc}, where each Markov state represents a workload scenario.
At runtime, the \gls{ibc} system switches between workload scenarios based on image workload. Having too many switching workload scenarios results in an unstable system or degrades system performance. 
This thesis thus proposes system-scenario identification that abstracts multiple workload scenarios based on camera frame rate, sensing delay and sampling period into system scenarios. The \gls{dtmc} is then recomputed, considering only the system scenarios, and the controller is synthesised based on the \gls{mjls} formulation.

The fifth contribution explores approximate computing as a means to reduce the effective sensor-to-actuator delay and the sampling period.
Approximate computing trades off accuracy in the signal processing for gains in response time.  Approximation is in that sense complementary to parallelizing and pipelining the control loop.
This thesis also presents the \gls{imacs} framework for analysing and validating the impact of injecting errors in the image processing on the closed-loop \gls{ibc} system performance.
In addition, this thesis proposes an approximation-aware control design that takes as input the quantified error due to approximation.

In conclusion, this thesis aims to efficiently cope with the long variable sensing delay of \gls{ibc} systems so that engineers can deploy \gls{ibc} systems efficiently in time- and safety-critical domains. An \gls{ibc} system uses computer-vision algorithms for sensing and control laws and algorithms for control regulation. The performance of the \gls{ibc} system is dependent on the performance of both the sensing and control algorithms. The presented \gls{spade} flow brings together two modeling and analysis paradigms in an integral way -- the dataflow formalism and control theory. As a means for optimization, both platform-specific aspects and application-specific characteristics are considered in various contributions presented in this thesis. This thesis also describes the way to adapt the \gls{spade} flow for both custom-made and industrial platforms, by considering several relevant design aspects such as image-workload variations, inter-frame dependencies, system nonlinearities and so on. 

\section{Future work}
This thesis proposes the \acrlong{spade} for multiprocessor \gls{ibc} systems implementation for an efficient model-driven optimisation.
There are various ways to extend the \gls{spade} flow for completeness and adoption in practice, which are interesting for future work. In the following, we present a few major future directions.

\begin{itemize}
    \item \textbf{Automated model extraction:} Extracting the application and platform models automatically from algorithmic descriptions of the application and a given platform allocation is an important future direction to enable a wider usage of formal model-based design and an analysis framework such as \gls{spade}. The model extraction is often tricky and error-prone in many real-life scenarios. A model-based design approach thrives on the accuracy of the inherent models. The current \gls{spade} approach assumes that the application graph and the platform graph are given or modelled by the designer. An automated approach to extract these models for a given algorithmic implementation and for a given platform allocation is helpful for adoptability of the proposed model-based approaches in industry  and avoiding manual efforts/errors in the modelling.
    \item \textbf{Analytical \gls{wcet} computation:} The application modelling in the \gls{spade} flow using \gls{sadf} requires the \gls{wcet} of tasks (actors in the \gls{sadf} model). For industrial platforms, the \gls{wcet} analysis of tasks running on the platform is non-trivial. An adaptation of how runtime profiling can be used for the proposed \gls{spade} flow is detailed in this thesis. The worst-case system scenario is identified (see Chapter~\ref{chap:pipelined_parallelism}) based on the profiled \gls{wcet} and may not be the actual \gls{wcet}. Computing the analytical \gls{wcet} bound for tasks running on an industrial platform is hard and still an open problem. A tighter \gls{wcet} bound is a helpful addition for the industrial adoption of the \gls{spade} flow and can potentially improve the performance of the overall design. An exact \gls{wcet} bound, typically obtained from predictable platforms, can maximise the system performance when using the \gls{spade} approach.
    \item \textbf{Scalablility:} Scalability of the current \gls{spade} flow is dependent on the \gls{sadf} analysis and mapping (using the SDF3 tool in this thesis). As the size of the input \gls{sadf} model grows, state-space explosion may be encountered during the analysis and mapping depending on the algorithms used for sensing. In particular, a meaningful addition to the framework is the ability to handle and treat \glspl{dnn}-based sensing as an alternative to classical computer-vision algorithms used in this thesis. Given the wide-spread use of \glspl{dnn} in various domains these days, it is a natural step forward where the challenge of long processing (inference) latency is even more valid. Typically, \glspl{dnn} are huge and using them directly in the dataflow analysis is challenging and may lead to state-space explosion. A possible direction of future work is to consider optimisation techniques for dataflow analysis and mapping with constraints on latency of the \gls{sadf} model along with the throughput-constraint, i.e., latency- and throughput-aware binding and scheduling. 
    \item \textbf{Code generation:} The \gls{spade} flow does currently not offer a code-generation capability. An industrial model-based design flow typically expects code-generation functionality to be embedded within the framework. Integrating a code-generation capability for the implementation is another interesting and useful direction for future work.
\end{itemize}

In addition, the  following future directions would make the \gls{spade} flow more complete without adding fundamentally new features.
\begin{itemize}
    \item A \gls{spade} adaptation for data-/compute-intensive control compute tasks (e.g., a compute-intensive \gls{mpc} or path planning) is another interesting direction to explore for future work. In this thesis, the assumption is that the control compute and actuation tasks are not compute-intensive. Another implicit assumption is that the sensing task output is available before the control compute task can start. A compute-intensive control task implies that we can parallelise the control task and potentially even pipeline its execution. 
    For a non-pipelined implementation, the sensing and control tasks are sequential and hence the compute-intensive control compute task results in longer delays and optimal control strategies are required for addressing the longer delay.
    For a pipelined implementation, the \gls{spade} flow considers a constant sampling period and as fast as possible sensing. In this choice of control design, the control compute task uses the latest sensing data available at the start of its execution. If the control compute task is unnecessarily delayed, some sensing data needs to wait longer before it is processed by the control task. Hence, the control compute task needs priority for mapping and scheduling.  
    The interplay between a compute-intensive control task and the data-intensive sensing task needs to be explored carefully. 
    The \gls{spade} flow can still be used, but the \gls{dse} needs further scrutiny.
    
    \item Considering multiple applications including one or more \gls{ibc} applications sharing a platform is not explored in this thesis in detail. The current \gls{spade} flow takes a single \gls{ibc} application as input. Multiple input applications give additional optimisation options for mapping, controller design and scheduling. A careful consideration of these optimisation options is needed for scalability and performance.
    The \gls{spade} flow extension for considering multiple (\gls{ibc}) applications is an interesting future work.
    
    \item The case study considered for demonstrating the current \gls{spade} approach assumes a \gls{siso} control system. Although the \gls{spade} theory allows in principle a design for \gls{mimo} control systems, the technical challenges still need to be addressed. A \gls{mimo} system, for instance, could have multiple sensors. This could mean that the information is coming at multiple rates. A control mechanism to deal with these multiple rates could also have implementation constraints. And the mapping design space is enlarged. This is again an interesting direction for future work.
    \item In this thesis, we have shown how multiple controller design methods can be integrated with the \gls{spade} approach.
    However, a rigorous analysis on identifying the controller design technique that is optimal for a given application and platform has not been done. This is another interesting direction for future work.
\end{itemize}